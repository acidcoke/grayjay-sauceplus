import { md5 } from "js-md5"
import fetch from "sync-fetch"

function init() {
    const local_plugin: typeof plugin = {
        config: { id: "c70eec9a-2cf4-46a3-8ab3-e1537ea1a2a3" },
        settings: {}
    }
    // @ts-expect-error hack to inject constant
    globalThis.plugin = local_plugin
    const is_testing = false
    // @ts-expect-error hack to inject constant
    globalThis.IS_TESTING = is_testing
    const local_source: Source<Readonly<Record<string, string>>, string, FeedType, FeedType, FeedType, unknown> = {}
    // @ts-expect-error hack to inject constant
    globalThis.source = local_source
    globalThis.log = console.log
    const type: GaryjayTypes = {
        Source: {
            Dash: "DASH",
            HLS: "HLS",
            STATIC: "Static"
        },
        Feed: {
            Videos: "VIDEOS",
            Live: "LIVE",
            Mixed: "MIXED",
            Shorts: "SHORTS",
        },
        Order: {
            Chronological: "Latest releases",
            Views: "Most played",
            Favorites: "Most favorited",
            Oldest: "Oldest"
        },
        Date: {
            LastHour: "LAST_HOUR",
            Today: "TODAY",
            LastWeek: "LAST_WEEK",
            LastMonth: "LAST_MONTH",
            LastYear: "LAST_YEAR"
        },
        Duration: {
            Short: "SHORT",
            Medium: "MEDIUM",
            Long: "LONG"
        },
        Text: {
            RAW: 0,
            HTML: 1,
            MARKUP: 2
        },
        Chapter: {
            NORMAL: 0,
            SKIPPABLE: 5,
            SKIP: 6,
            SKIPONCE: 7
        }
    }
    // @ts-expect-error hack to inject constant
    globalThis.Type = type
    const language: LanguageOptions = {
        UNKNOWN: "Unknown",
        ARABIC: "ar",
        SPANISH: "es",
        FRENCH: "fr",
        HINDI: "hi",
        INDONESIAN: "id",
        KOREAN: "ko",
        PORTUGUESE: "pt",
        // PORTBRAZIL: "pt",
        RUSSIAN: "ru",
        THAI: "th",
        TURKISH: "tr",
        VIETNAMESE: "vi",
        ENGLISH: "en",
        GERMAN: "de"
    }
    // @ts-expect-error hack to inject constant
    globalThis.Language = language
    function LOCAL_HTTP_GET(url: string, headers: HTTPHeaders, use_auth_client: boolean): BridgeHttpResponse<string>
    function LOCAL_HTTP_GET(url: string, headers: HTTPHeaders, use_auth_client: boolean, use_byte_response: true): BridgeHttpResponse<Uint8Array>
    function LOCAL_HTTP_GET(url: string, headers: HTTPHeaders, use_auth_client: boolean, use_byte_response?: true): BridgeHttpResponse<string> | BridgeHttpResponse<Uint8Array> {
        if (use_byte_response) {
            throw new ScriptException("use_byte_response is unsupported during testing")
        }
        return http.request("GET", url, headers, use_auth_client)
    }

    function LOCAL_HTTP_POST(url: string, body: string | Uint8Array, headers: HTTPHeaders, use_auth_client: boolean): BridgeHttpResponse<string>
    function LOCAL_HTTP_POST(url: string, body: string | Uint8Array, headers: HTTPHeaders, use_auth_client: boolean, use_byte_response: true): BridgeHttpResponse<Uint8Array>
    function LOCAL_HTTP_POST(url: string, body: string | Uint8Array, headers: HTTPHeaders, use_auth_client: boolean, use_byte_response?: true): BridgeHttpResponse<string> | BridgeHttpResponse<Uint8Array> {
        if (use_byte_response) {
            throw new ScriptException("use_byte_response is unsupported during testing")
        }
        return http.requestWithBody("POST", url, body, headers, use_auth_client)
    }

    const local_http: HTTP = {
        GET: LOCAL_HTTP_GET,
        POST: LOCAL_HTTP_POST,
        request(method: string, url: string, headers: HTTPHeaders, use_auth_client: boolean): BridgeHttpResponse<string> {
            log(use_auth_client)
            const options = {
                method,
                headers
            }
            const res = fetch(url, options)
            const body = res.text()
            const code = res.status
            if (code !== 404 && code !== 200 && code !== 403) {
                throw new ScriptException(`unimplemented code: ${code}`)
            }
            return { body, code, headers: { error: ["headers not implemented"] }, url, isOk: res.ok }
        },
        requestWithBody(method: string, url: string, body: string | Uint8Array, headers: HTTPHeaders, use_auth_client: boolean): BridgeHttpResponse<string> {
            log(use_auth_client)
            const options = {
                method,
                body,
                headers
            }
            const res = fetch(url, options)
            const res_body = res.text()
            const code = res.status
            if (code !== 404 && code !== 200 && code !== 403) {
                throw new ScriptException(`unimplemented code: ${code}`)
            }
            return { body: res_body, code, headers: { error: ["headers not implemented"] }, url, isOk: res.ok }
        },
        batch() {
            return new Batcher()
        },
        socket(url: string, headers: HTTPHeaders, use_auth_client: boolean): SocketResult {
            log("socket not implemented")
            log(url)
            log(headers)
            log(use_auth_client)
            return {
                isOpen: false,
                send(msg: string): void {
                    log("socket not implemented")
                    log(msg)
                },
                connect(socketObj: SocketObject): void {
                    log("socket not implemented")
                    log(socketObj)
                },
                close(): void {
                    log("socket not implemented")
                }
            }
        },
        newClient(with_auth: boolean): HTTPClient {
            log(with_auth)
            throw new Error("not implemented")
        },
        getDefaultClient(with_auth: boolean): HTTPClient {
            log(with_auth)
            throw new Error("not implemented")
        }
    }
    // @ts-expect-error hack to inject constant
    globalThis.http = local_http
    interface RequestData {
        method: MethodWithoutBody | MethodWithBody
        url: string
        headers: HTTPHeaders
        use_auth_client: boolean
    }
    interface RequestWithBodyData extends RequestData {
        body: string
        method: MethodWithBody
    }
    interface RequestWithoutBodyData extends RequestData {
        method: MethodWithoutBody
    }

    const local_utility = {
        toBase64(byte_array: Uint8Array): string {
            return btoa(bytes_to_string(byte_array))
        },
        fromBase64(encoded_string: string): Uint8Array {
            log(encoded_string)
            throw new Error("not implemented")
        },
        md5String(str: string): string {
            return md5(str)
        }
    }
    // @ts-expect-error hack to inject constant
    globalThis.utility = local_utility

    const local_dom_parser: GrayjayDOMParser = {
        parseFromString(html: string): DOMNode {
            log(html)
            throw new Error("not implemented")
        }
    }
    // @ts-expect-error hack to inject constant
    globalThis.domParser = local_dom_parser

    function bytes_to_string(bytes: Uint8Array): string {
        let result = ""
        for (const byte of bytes) {
            result = result + String.fromCharCode(byte)
        }
        return result
    }

    class Batcher implements BatchBuilder {
        requests: (RequestWithoutBodyData | RequestWithBodyData)[] = []
        GET(this: Batcher, url: string, headers: HTTPHeaders, use_auth_client: boolean): Batcher {
            this.requests.push({ method: "GET", url, headers, use_auth_client })
            return this
        }
        POST(this: Batcher, url: string, body: string, headers: HTTPHeaders, use_auth_client: boolean): Batcher {
            this.requests.push({ method: "POST", url, body, headers, use_auth_client })
            return this
        }
        execute(this: Batcher): BridgeHttpResponse<string>[] {
            return this.requests.map((request) => {
                if ("body" in request) {
                    return http.requestWithBody(request.method, request.url, request.body, request.headers, request.use_auth_client)
                }
                return http.request(request.method, request.url, request.headers, request.use_auth_client)
            })
        }
    }

    class ContentPager {
        plugin_type: "ContentPager"
        results: IPlatformContent[]
        hasMore: boolean
        constructor(results: IPlatformContent[], hasMore: boolean) {
            this.plugin_type = "ContentPager"
            this.results = results
            this.hasMore = hasMore
        }

        hasMorePagers() { return this.hasMore }
        nextPage(): this {
            this.hasMore = false
            this.results = []
            return this
        }
    }
    // @ts-expect-error hack to inject constant
    globalThis.ContentPager = ContentPager
    class VideoPager {
        plugin_type: "VideoPager"
        results: PlatformVideo[]
        hasMore: boolean
        constructor(results: PlatformVideo[], hasMore: boolean) {
            this.plugin_type = "VideoPager"
            this.results = results
            this.hasMore = hasMore
        }

        hasMorePagers() { return this.hasMore }
        nextPage(): this {
            this.hasMore = false
            this.results = []
            return this
        }
    }
    // @ts-expect-error hack to inject constant
    globalThis.VideoPager = VideoPager
    class ChannelPager {
        plugin_type: "ChannelPager"
        results: PlatformChannel[]
        hasMore: boolean
        constructor(results: PlatformChannel[], hasMore: boolean) {
            this.plugin_type = "ChannelPager"
            this.results = results
            this.hasMore = hasMore
        }

        hasMorePagers() { return this.hasMore }
        nextPage(): this {
            this.hasMore = false
            this.results = []
            return this
        }
    }
    // @ts-expect-error hack to inject constant
    globalThis.ChannelPager = ChannelPager
    class CommentPager<T extends Readonly<Record<string, string>>> {
        plugin_type: "CommentPager"
        results: PlatformComment<T>[]
        hasMore: boolean
        constructor(results: PlatformComment<T>[], hasMore: boolean) {
            this.plugin_type = "CommentPager"
            this.results = results
            this.hasMore = hasMore
        }

        hasMorePagers() { return this.hasMore }
        nextPage() {
            this.hasMore = false
            this.results = []
            return this
        }
    }
    // @ts-expect-error hack to inject constant
    globalThis.CommentPager = CommentPager
    class PlaylistPager {
        readonly plugin_type = "PlaylistPager" as const
        results: PlatformPlaylist[]
        hasMore: boolean
        constructor(results: PlatformPlaylist[], hasMore: boolean) {
            this.plugin_type = "PlaylistPager"
            this.results = results
            this.hasMore = hasMore
        }

        hasMorePagers() { return this.hasMore }
        nextPage() {
            this.hasMore = false
            this.results = []
            return this
        }
    }
    // @ts-expect-error hack to inject constant
    globalThis.PlaylistPager = PlaylistPager
    class PlatformAuthorLink {
        readonly id: PlatformID
        readonly name: string
        readonly url: string
        readonly thumbnail?: string
        readonly subscribers?: number
        readonly membershipUrl?: string
        constructor(id: PlatformID, name: string, url: string, thumbnail?: string, subscribers?: number, membershipUrl?: string) {
            this.id = id
            this.name = name
            this.url = url
            if (thumbnail !== undefined) {
                this.thumbnail = thumbnail
            }
            if (subscribers !== undefined) {
                this.subscribers = subscribers
            }
            if (membershipUrl !== undefined) {
                this.membershipUrl = membershipUrl
            }
        }
    }
    // @ts-expect-error hack to inject constant
    globalThis.PlatformAuthorLink = PlatformAuthorLink
    class PlatformID {
        readonly platform: string
        readonly value: string
        readonly pluginId: string
        readonly claimType: number
        readonly claimFieldType: number
        constructor(platform: string, id: string, pluginId: string, claimType?: number, claimFieldType?: number) {
            this.platform = platform
            this.pluginId = pluginId
            this.value = id
            this.claimType = claimType ?? 0
            this.claimFieldType = claimFieldType ?? -1
        }
    }
    // @ts-expect-error hack to inject constant
    globalThis.PlatformID = PlatformID
    class PlaybackTracker {
        readonly nextRequest: number
        constructor(interval: number) {
            this.nextRequest = interval ?? 10 * 1000
        }
    }
    // @ts-expect-error hack to inject constant
    globalThis.PlaybackTracker = PlaybackTracker
    class Thumbnail {
        constructor(private readonly url: string, private readonly quality: number) {
            log(`new Thumbnail url: ${this.url} quality: ${this.quality}`)
        }
    }
    // @ts-expect-error hack to inject constant
    globalThis.Thumbnail = Thumbnail
    class Thumbnails {
        readonly sources: Thumbnail[]
        constructor(thumbnails: Thumbnail[]) {
            this.sources = thumbnails
        }
    }
    // @ts-expect-error hack to inject constant
    globalThis.Thumbnails = Thumbnails
}

init()
